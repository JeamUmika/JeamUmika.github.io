{"pages":[{"title":"","text":"关于 (⑅˃◡˂⑅) (๑• . •๑) 关于本站 本站主要是用于记录一些可有可无的琐事。 本人自述 有时侯像一条没有梦想的咸鱼，有时侯像一只勤奋的小仓鼠。 学过一点前端知识。肚子饿的时候就翻网络垃圾桶找垃圾吃。 本站的主题源码：🔗","link":"/about/index.html"},{"title":"","text":"友链 便当的梅开四度在学习！","link":"/friends/index.html"}],"posts":[{"title":"公告","text":"由于各种因素，本站暂时停止发布新文章，部分文章还会进行更新（随缘） ——2022-1-15","link":"/posts/43ee71e3.html"},{"title":"提供一些学习的便利","text":"前言在GitHub上面搭建的图床可能国内的用户访问不了，这里提供一些便利，仅供学习，不可商用，所造成的后果本站概不负责。 注意：本文章不提供任何有关使用节点和虚拟专用网的教程。 严禁未成年人和自制力差的人使用，未成年人和自制力差的人请自觉离开。 节点池项目地址：🔗 由于安全问题，请不要在使用节点池的节点时输入敏感信息（比如密码等） 从网络上收集而来的部分节点池： http://8.135.91.61/ https://fq.lonxin.net/ http://www.fuckgfw.tk/ https://149.248.8.112/ http://39.106.12.141:8081/ https://hellopool.herokuapp.com/ https://smart.zxcyec.top/ https://free.kingfu.cf/ https://sspool.nl/ https://www.joemt.tk/ http://wxshi.top:9090/ https://proxy.whuboy.com/ http://104.128.81.6:8080/ http://149.248.8.112/ https://hk.xhrzg2017.xyz/ http://23.105.206.34:9999/ http://173.82.104.122/ https://free886.herokuapp.com/ https://outseen.tk/ https://192.3.251.87/ https://proxies.bihai.cf/ https://140.238.42.191/ https://www.linbaoz.com/ http://213.188.195.234/ https://proxypool-guest997.herokuapp.com/ https://sspool.herokuapp.com/ https://alexproxy003.herokuapp.com/ https://origamiboy.herokuapp.com/ http://guobang.herokuapp.com/ https://us-proxypool.herokuapp.com/ https://eu-proxypool.herokuapp.com/ https://free.dswang.ga/ http://158.101.93.192/ https://zua426.cf/ 虚拟专用网（virtual private network）一些国内还能访问的科学上网工具下载网站（官网） AdGuard VPN V2Ray/VLESS+Heroku项目地址：🔗","link":"/posts/dd62e41d.html"},{"title":"test","text":"","link":"/posts/d87f7e0c.html"},{"title":"hexo与GitHub Actions的集成部署","text":"前言由于网上的那些关于“hexo与GitHub Actions的集成部署”的文章绝大多数都是部署失败的，少数的是因为不再想试了，所以在这重写一次。 如果没有说明，请不要乱修改 提示：如果仅仅是不想在本地生成静态文件（hexo g）的话建议那建议看：hexo与GitHub Actions的自动化部署 前提 已经在本地搭建好了博客，如果还没有请访问hexo官网：🔗 如果不知道怎么push到GitHub私有仓库上，则请在网上搜索教程：Google Search，或者下载GitHub Desktop把博客根目录上传就行：GitHub Desktop 这是上传博客根目录后在GitHub上的内容（GitHub Desktop会自动把非必要的文件或文件夹留在本地，必要的就上传） 开始 在GitHub上面创建两个仓库，一个是用于展示博客的公有仓库（这里用xxx.github.io代替公有仓库），一个是用于放博客源代码的私有仓库 在你博客根目录下用cmd或者git bash执行（注意修改指令里面的指定内容） 1ssh-keygen -f hexo-deploy-key -C &quot;xxx.github.io&quot; 执行完后在你本地博客根目录会出现两个文件 ​ 私钥：hexo-deploy-key ​ 公钥：hexo-deploy-key.pub 私钥在你的私有仓库里依次点击Settings -&gt; Secrets -&gt; Actions -&gt; New repository secret Name填DEPLOY_KEY，Value填hexo-deploy-key里面的全部内容，点击Add secret就可以了 公钥在你的私有仓库里依次点击Settings -&gt; Deploy keys -&gt; Add deploy key Title填DEPLOY_KEY（Title可以填别的内容），Key填公钥里的所有内容，勾上Allow write access，最后点击Add key就可以了 修改打开博客根目录下的_config.yml，修改deploy下的repo为ssh格式：（注意修改里面的指定内容） 1repo: git@github.com:your_github_name/xxx.github.io.git 创建在博客根目录下找到.github这个文件夹，在里面创建名为workflows的文件夹，再在workflows里面新建一个名为xxx.yml的文件（xxx可以改成别的名字） 在xxx.yml文件里面写入以下内容（注意里面的分支） 第31行把xx改成你的GitHub邮箱（用于发送未完成部署的信息） 第32行把xx改成你GitHub的名字 1234567891011121314151617181920212223242526272829303132333435363738394041name: Hexo Deployon: # 监听私有仓库的分支，如果想监听所有分支则将on: ~ - main改成on: [push] push: branches: - mainjobs: build: runs-on: ubuntu-latest if: github.event.repository.owner.id == github.event.sender.id steps: # 获取博客源码和主题 - name: Checkout source uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: '14' # 使用node.js的版本（不要太高） - name: Setup Hexo env: ACTION_DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }} # 获取私钥及部署 run: | mkdir -p ~/.ssh/ echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa chmod 700 ~/.ssh chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.email &quot;xxxxxx@xx.com&quot; git config --global user.name &quot;xxxx&quot; npm install hexo-cli -g npm install npm install hexo --save npm install --save hexo-pagination@^2.0.0 - name: Deploy run: | hexo clean hexo deploy 最后将内容push到私有仓库Workflows就会自动将博客部署了 看私有仓库的Actions，绿色的是部署成功，红色的是失败 附加hexo与GitHub Actions的集成部署不是完美的，比如本站用 hexo-auto-excerpt 这个hexo插件就只生效一半（没有按照我修改的来渲染，只按插件默认的），这种情况就跟前言提到的自动化部署一起使用就解决了 完成","link":"/posts/761615aa.html"},{"title":"使用GitHub Actions来对hexo进行自动部署","text":"前言由于网上关于使用GitHub Actions自动部署hexo的教程全都是那种已经过期的，跟吃泻药似的，实在是折磨人。（简直是气死我了😞） 所以本人自己写一遍。（非集成部署，集成部署看这：🔗） 开始在本地博客的根目录下找到.deploy_git\\.github\\workflows\\如果没有这个文件夹就创建新的，然后就在workflows这个文件夹里面创建一个xxx.yml的文件（xxx可以自定义），在xxx.yml文件里输入下面的全部内容 第33行的xx填你注册GitHub的邮箱，用于部署失败时GitHub给你发邮箱 第34行的xx填你这个GitHub账号的名字 1234567891011121314151617181920212223242526272829name: Hexo Deployon: push: branches: - mainjobs: build: runs-on: ubuntu-latest steps: - name: Checkout source uses: actions/checkout@v2 - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: '14' - name: Setup Hexo run: | npm install hexo-cli -g npm install - name: Deploy run: | hexo clean hexo deploy 写完文章直接运行下面指令让GitHub帮你部署就行了就可以了 1hexo d 完成！","link":"/posts/5da6ff17.html"},{"title":"一些实用的工具","text":"前言这里只列举一些个人认为比较实用的工具。 Real-ESRGAN项目地址：🔗 介绍：一款可以强大的图像修复工具，不仅可以修复图片而且还可以修复视频（视频可以配合FFmpag来修复，主要是用FFmpag来切割） 说明：开源免费软件 第三方GUI： Waifu2x-Extension-GUI 部分功能展示： FFmpag官网：🔗 介绍：FFmpeg是一款强大的多媒体框架，你可以用它来解码、编码、转码、切割视频等 说明：开源免费软件 第三方GUI： ffmpegGUI Axiom snipaste官网：🔗 介绍：一个强大的截图+贴图工具 说明：付费软件，但有免费版的 部分功能展示： Beyond Compare官网：🔗 介绍：一款实用的比较工具（主要）以及参杂了一些别的功能 说明：付费软件 部分功能展示： QTranslate官网：🔗 介绍： 一款便捷的翻译软件，选中即可翻译 说明：免费软件 部分功能展示： Total Commander官网：🔗 介绍：一款功能强大的文件管理器，能明显地提高工作效率，不过学习成本也稍高 说明：付费软件 部分功能展示：","link":"/posts/82053e7e.html"},{"title":"与Windows10&quot;已连接，无Internet&quot;类似的断网问题","text":"已连接，无Internet 原因 DNS服务器出错。比如使用了谷歌DNS这种国内连不上的DNS（一般都是用户自己修改的，改回默认的就行） 可能是DNS的缓存造成的 解决 重置DNS 点击上上图的“疑难解答”按流程操作可能就能解决了，也可以用类似于“360”的“网络诊断”来解决。 刷新DNS缓存 以下方法来自bilibili的@星仔跑天涯 打开DOS命令窗口，输入ipconfig/flushdns，重启电脑即可","link":"/posts/b1596bd1.html"},{"title":"卸载npm包的正确操作","text":"简述执行类似于npm uninstall &lt;package&gt;指令时有的人会出现up to date而不是removed * packages的情况，这是由于多加了版本号导致的 解决方案也很简单，把版本号去掉就行啦^_^","link":"/posts/861d4eb4.html"},{"title":"解决出现undefined.html以及上传文章不显示的bug","text":"简述如图所示（上传文章而不显示的图片就不给出来了） 是使用了hexo-abbrlink造成的，主要还是把*.md的文件名改了导致的。操作过程：用指令生成一个abcd.md然后再把abcd.md改成abc.md，如果没有执行hexo clean就会出现undefined.html的情况，否则会出现不显示文章的情况。 解决：进入_config.yml把permalink这行后面的.html删掉或者把l删掉 执行 12hexo cleanhexo g 再改回来再次执行上面的指令就行了","link":"/posts/1a8ab364.html"},{"title":"github图床","text":"前言注意：如果是用GitHub搭建的博客，为了安全不建议把图床跟网站放在同一个号 PicGo与GitHub Token在GitHub创建一个新仓库 到GitHub下载PicGo（注意下载位置，等下可能要用） 安装完成后进入PicGo，点击GitHub图床，填仓库名的格式你的账号名字/仓库名分支名填main就行 到GitHub创建一个新token，Note随便填，把下面的repo勾上就行，拉到下面保存之后会有一个令牌（别刷新网站不然令牌会“消失”)复制令牌填入PicGo的设定Token中，点击确认就行了 将Typora与PicGo“连体”点击Typora左上角的“文件”选择“偏好设置”，在“图像”里面的“上传服务”中选择“PicGo”，途径选择你的PicGo.exe就行 完成！","link":"/posts/4d9ab4ed.html"},{"title":"hexo与Gitalk","text":"前言由于Gitalk的评论界面简洁而且好看还支持markdown，所以相中了，记录一下折腾记录 项目链接 Gitalk 按照redme.md安装即可 由于本站所用的主题为fluid支持Gitalk所以可以不用安装直接修改_config.fluid.yml就行 动手注意：如果是用GitHub搭建的博客，为了安全不建议把评论跟网站放在同一个号 首先新建一个新的仓库（记住仓库名字下面要用） 到github的OAuth页面新建一个新的OAuth应用程序，应用名称随便填，其余两个就填你的博客地址就行 点击Generate a new client secret 下面是在_config.fluid.yml的配置，将上面的clientID和clientSecret复制到配置里 repo填你仓库的名字 owner填你仓库账号的名字，比如你叫aaa创了个bbb的仓库，就填aaa就行了 admin跟owner一样就可以了 代理可能会失效下面讲 代理先到cloudflre创建一个新账号（如果有的话就直接用就行） 再点击workers，点击新建一个服务（按默认的就行） 点击快速编辑 把左栏的内容全部删掉，复制以下内容进去，把whitelist后面的网址改成你自己的，点击保存并部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/*CORS Anywhere as a Cloudflare Worker!(c) 2019 by Zibri (www.zibri.org)email: zibri AT zibri DOT orghttps://github.com/Zibri/cloudflare-cors-anywhere*//*whitelist = [ &quot;^http.?://www.example.com$&quot;, &quot;example.com$&quot;, &quot;test\\\\..*&quot; ]; // regexp for whitelisted urls*/blacklist = [ ]; // regexp for blacklisted urls//whitelist = [ &quot;.*&quot; ]; // regexp for whitelisted originswhitelist = [ &quot;^http.?://jeam.xyz$&quot;, &quot;jeam.xyz$&quot; ]function isListed(uri,listing) { var ret=false; if (typeof uri == &quot;string&quot;) { listing.forEach((m)=&gt;{ if (uri.match(m)!=null) ret=true; }); } else { // decide what to do when Origin is null ret=true; // true accepts null origins false rejects them. } return ret;}addEventListener(&quot;fetch&quot;, async event=&gt;{ event.respondWith((async function() { isOPTIONS = (event.request.method == &quot;OPTIONS&quot;); var origin_url = new URL(event.request.url); function fix(myHeaders) { // myHeaders.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); myHeaders.set(&quot;Access-Control-Allow-Origin&quot;, event.request.headers.get(&quot;Origin&quot;)); if (isOPTIONS) { myHeaders.set(&quot;Access-Control-Allow-Methods&quot;, event.request.headers.get(&quot;access-control-request-method&quot;)); acrh = event.request.headers.get(&quot;access-control-request-headers&quot;); //myHeaders.set(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); if (acrh) { myHeaders.set(&quot;Access-Control-Allow-Headers&quot;, acrh); } myHeaders.delete(&quot;X-Content-Type-Options&quot;); } return myHeaders; } var fetch_url = decodeURIComponent(decodeURIComponent(origin_url.search.substr(1))); var orig = event.request.headers.get(&quot;Origin&quot;); var remIp = event.request.headers.get(&quot;CF-Connecting-IP&quot;); if ((!isListed(fetch_url, blacklist)) &amp;&amp; (isListed(orig, whitelist))) { xheaders = event.request.headers.get(&quot;x-cors-headers&quot;); if (xheaders != null) { try { xheaders = JSON.parse(xheaders); } catch (e) {} } if (origin_url.search.startsWith(&quot;?&quot;)) { recv_headers = {}; for (var pair of event.request.headers.entries()) { if ((pair[0].match(&quot;^origin&quot;) == null) &amp;&amp; (pair[0].match(&quot;eferer&quot;) == null) &amp;&amp; (pair[0].match(&quot;^cf-&quot;) == null) &amp;&amp; (pair[0].match(&quot;^x-forw&quot;) == null) &amp;&amp; (pair[0].match(&quot;^x-cors-headers&quot;) == null) ) recv_headers[pair[0]] = pair[1]; } if (xheaders != null) { Object.entries(xheaders).forEach((c)=&gt;recv_headers[c[0]] = c[1]); } newreq = new Request(event.request,{ &quot;headers&quot;: recv_headers }); var response = await fetch(fetch_url,newreq); var myHeaders = new Headers(response.headers); cors_headers = []; allh = {}; for (var pair of response.headers.entries()) { cors_headers.push(pair[0]); allh[pair[0]] = pair[1]; } cors_headers.push(&quot;cors-received-headers&quot;); myHeaders = fix(myHeaders); myHeaders.set(&quot;Access-Control-Expose-Headers&quot;, cors_headers.join(&quot;,&quot;)); myHeaders.set(&quot;cors-received-headers&quot;, JSON.stringify(allh)); if (isOPTIONS) { var body = null; } else { var body = await response.arrayBuffer(); } var init = { headers: myHeaders, status: (isOPTIONS ? 200 : response.status), statusText: (isOPTIONS ? &quot;OK&quot; : response.statusText) }; return new Response(body,init); } else { var myHeaders = new Headers(); myHeaders = fix(myHeaders); if (typeof event.request.cf != &quot;undefined&quot;) { if (typeof event.request.cf.country != &quot;undefined&quot;) { country = event.request.cf.country; } else country = false; if (typeof event.request.cf.colo != &quot;undefined&quot;) { colo = event.request.cf.colo; } else colo = false; } else { country = false; colo = false; } return new Response( &quot;CLOUDFLARE-CORS-ANYWHERE\\n\\n&quot; + &quot;Source:\\nhttps://github.com/Zibri/cloudflare-cors-anywhere\\n\\n&quot; + &quot;Usage:\\n&quot; + origin_url.origin + &quot;/?uri\\n\\n&quot; + &quot;Donate:\\nhttps://paypal.me/Zibri/5\\n\\n&quot; + &quot;Limits: 100,000 requests/day\\n&quot; + &quot; 1,000 requests/10 minutes\\n\\n&quot; + (orig != null ? &quot;Origin: &quot; + orig + &quot;\\n&quot; : &quot;&quot;) + &quot;Ip: &quot; + remIp + &quot;\\n&quot; + (country ? &quot;Country: &quot; + country + &quot;\\n&quot; : &quot;&quot;) + (colo ? &quot;Datacenter: &quot; + colo + &quot;\\n&quot; : &quot;&quot;) + &quot;\\n&quot; + ((xheaders != null) ? &quot;\\nx-cors-headers: &quot; + JSON.stringify(xheaders) : &quot;&quot;), {status: 200, headers: myHeaders} ); } } else { return new Response( &quot;Create your own cors proxy&lt;/br&gt;\\n&quot; + &quot;&lt;a href='https://github.com/Zibri/cloudflare-cors-anywhere'&gt;https://github.com/Zibri/cloudflare-cors-anywhere&lt;/a&gt;&lt;/br&gt;\\n&quot; + &quot;\\nDonate&lt;/br&gt;\\n&quot; + &quot;&lt;a href='https://paypal.me/Zibri/5'&gt;https://paypal.me/Zibri/5&lt;/a&gt;\\n&quot;, { status: 403, statusText: 'Forbidden', headers: { &quot;Content-Type&quot;: &quot;text/html&quot; } }); } } )());}); 点击中间的发送 复制Usage下面的链接 接上下面的尾部 1https://github.com/login/oauth/access_token 例子 1https://gitalk.example.workers.dev/?https://github.com/login/oauth/access_token 把它粘贴到代理后面即可 完成！","link":"/posts/d8711f7.html"},{"title":"一些hexo插件","text":"这里只列举一些本站用到的hexo插件 功能 项目地址 文章置顶 hexo-generator-index-pin-top 生成URL短链 hexo-abbrlink Gitalk（基于GitHub的评论功能） gitalk 自动摘录 hexo-auto-excerpt sitemap.xml（网站地图） hexo-generator-sitemap 隐藏文章 hexo-hide-posts","link":"/posts/156bc16.html"},{"title":"网站搭建","text":"前言 为了节约时间成本这里采用热门的搭建方法 分为两大类 通过网站托管（无后端）（后端可用hexoplusplus来实现） 用云服务器搭建（有后端） 准备 电脑一台（如果用云服务器搭建没电脑也行）（没电脑又不想买服务器的可以看这个 使用Termux制作Hexo的详细攻略 ） 通过 GitHub 托管GitHub上面的操作 托管网站有很多，如 GitHub 、Vercel 、cloudflare page 等等。虽然种类繁多，但是流程都是差不多的。 在 GitHub 上面注册一个账号 创建一个新仓库 “xxx”是填你的网站名，然后点击“create repository” 点击“设置” 点击“页面” 选择一个主题 圈着的网址就是新搭建的网站了（记住这个网址，下面仓库链接要填这个) 电脑上面的操作 下载并安装 nodejs(长期维护版) 、Git 安装过程直接点下一步就行，不过nodejs要改一个地方，如图，点击 “Add to PATH”再点 “Next” 新创建一个文件夹（用来装你博客的文件） 在路径中输入“cmd”然后回车 在“cmd”里输入以下内容并回车 1npm install hexo-cli -g 等上面的完成后再输入以下内容并回车 1hexo init 如果执行hexo init失败就执行下面指令 1npm i 安装部署插件 1npm install --save hexo-deployer-git 下面是没安装部署插件的情况 已经部署好环境了，下面修改一些内容 下载 Notepad（用于编辑*.yml等类型文件）、Typora（用于写*.md的博客文章） 在装有你的博客的文件夹里找到_config.yml，右键用Notepad++打开，改动以下内容 第5行是你网站的名字（非必要） 第8行是描述网站的内容（非必要） 第10行是你自己（非必要） 第11行是语言（非必要） 第16行填你的网址（必要） 第65行跟第88行的10改成12（非必要） 第100行是你的主题名字（在你的博客文件夹/theme 里）（可以在GitHub里找你想要的主题 链接 ，下载后放在theme这个文件夹里，并把第100行的名字改成你主题的名字（必要） 修改第104至107行，其中第106行的是你的仓库链接（必要） 下面复制的就是你的仓库链接了 用来装文章的文件夹_posts（在写文章的时候也可以直接在这里创建新的*.md文件来写） 部署到GitHub上输入以下指令 1npm install hexo-deployer-git --save 完成后再上传 1hexo g -d 如果失败，则输入以下指令，再输入上面的指令： 1git config --global credential.helper wincred 创建新文章 1hexo n 你文章的名字 清除缓存的指令（只是发表文章不用）（如果出现了什么错误可以clean以下试试） 1hexo clean 生成静态网页文件的指令 1hexo g 访问本地博客（Ctrl + c 关闭） 1hexo s 部署到GitHub上（必须先生成静态网页） 1hexo d 可以说通过GitHub托管的内容就在这里结束了 用云服务器搭建买云服务器注：国内的云服务器搭建网站要备案，一般要二十多天才能通过，也就是说在未通过的时间里你的域名是无法在国内的云服务器上使用的 国内有名的云服务器提供商有腾讯云、阿里云 等，国外的有Vultr、搬瓦工、Google Cloud 等。国内的提供商一般会在双11这种日子抛售云服务器（不妨到淘宝或者其他地方找找可能会有更便宜的）如果只是用来自己访问的（一年都没有超过三位数的访问量）可以选择较低配置的云服务器（阿里云新用户送一台国内的服务器30天） 更换安全组这里以阿里云ECS服务器为例，先到实例里面添加安全组 添加打勾的那三个，授权对象填自己的IP地址（到百度搜IP即可看见自己的IP地址） 更换系统——安装宝塔面板首先要停止实例并勾上实例，点击“更多” 搜索宝塔面板，使用第一个就是了 远程连接登录要密码，如果忘记密码可以重置密码 输入bt default 把URL的链接复制到浏览器里面，输入里面的username和password就行了 进入宝塔面板后如果有跳出来这个东西的话点击左边的一键安装，如果没有的话到左边的软件商店一个个下载安装就可以了，等待安装完成 PS：左边的只支持静态网页，右边的静态和动态都支持，但是左边的做静态网页更专业 安装完成后到软件商店里点击wordpress后面的一键部署 域名填实例的公有IP（如果有域名的话填域名，国内服务器域名要备案才能成功） 提交后点击访问站点输入数据库名、用户和密码就行了（记住在语言那里选择中文） 后面的自己看文字就会搞了 可以说到这里已经是搭建好了 域名一般服务器提供商那里都可以买域名，不过这里推荐namesilo，原因可参考这篇文章：🔗 namesilo续费可用优惠码：namesilo2022~2026 若不想买域名还可以白嫖别人的二级域名，这里提供两个网上找来的二级域名申请：🔗（推荐）、🔗（这个不知道什么时候跑路），需要其他二级域名的自己可以到网上找，或者参考：🔗 服务器和GitHub的域名解析这里以namesilo为例 进入我的账户里面 点击右边的域名管理domain manager 勾上你的域名，点击右边的蓝色小球，进入以后把原来的东西都删掉 服务器：一般点A就行然后HOSTNAME填@，IPV4地址填你服务器公网IP，TTL填3600，保存，再点击一次A，HOSTNAME填www其余的跟前面的一样 服务器的教程到这里已经结束了 ^_^ GitHub：点击A，HOSTNAME填@，IPV4地址填185.199.108.153保存，重复前面的继续填185.199.109.153，185.199.110.153，完成后再点击CNAME，HOSTNAME填www，Target Hostname填你创建网站的网址，如xxx.github.io 进入你的GitHub页面，在圈着的框里输入你的域名保存就ok了 在你本地的博客source目录里新建一个没后缀的CNAME文件，里面填你的网站，比如本站jeam.xyz 作用：为了不用每次上传博客文章或其他文件而导致域名要重新设置（就是要重复上面的那张图的步骤） 到这里可以说结束了 附加可能域名提供商提供的解析器太慢，所以这里推荐用cloudflare进行解析 这里以GitHub page为例 在cloudflare上面的操作首先得注册一个cloudflare账号，在主页点击添加站点 添加成功后点击左侧栏的DNS，点击添加记录，名称填@，内容填185.199.108.153保存，重复前面的继续填185.199.109.153，185.199.110.153，完成后再添加记录，在类型中选择CNAME，名称填www，内容填你创建网站的网址，如xxx.github.io 代不代理都行 在域名提供商上面的操作这里用namesilo为例，进入管理我的域界面，勾选你的域名，点击图中第二个按钮（两个箭头的那个） 将NameSever里面的全删了，加入emely.ns.cloudflare.com和maxim.ns.cloudflare.com，点击保存就行了 完成 ⭐由于个人能力有限，如有错误，还请广大网友不吝指正⭐ 此文章有被侵权记录：🔗","link":"/posts/338f9b1.html"},{"title":"MatLab 数学建模笔记（待完成）","text":"word文件链接： MATLAB-建立矩阵引用矩阵基本元素等基本操作 MatLab-矩阵处理 仅供学习，不可商用。","link":"/posts/e283e749.html"},{"title":"Nya","text":"","link":"/posts/410deaa9.html"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"MatLab","slug":"MatLab","link":"/tags/MatLab/"},{"name":"闲聊","slug":"闲聊","link":"/tags/%E9%97%B2%E8%81%8A/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"PicGo","slug":"PicGo","link":"/tags/PicGo/"},{"name":"Gitalk","slug":"Gitalk","link":"/tags/Gitalk/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"短链插件","slug":"短链插件","link":"/tags/%E7%9F%AD%E9%93%BE%E6%8F%92%E4%BB%B6/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"网站搭建","slug":"网站搭建","link":"/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"cloudflare","slug":"cloudflare","link":"/tags/cloudflare/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"闲聊","slug":"闲聊","link":"/categories/%E9%97%B2%E8%81%8A/"},{"name":"Web相关","slug":"Web相关","link":"/categories/Web%E7%9B%B8%E5%85%B3/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"PC","slug":"PC","link":"/categories/PC/"},{"name":"公告","slug":"公告","link":"/categories/%E5%85%AC%E5%91%8A/"}]}